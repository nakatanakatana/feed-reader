// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"
)

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds (
  uuid,
  url,
  link,
  title,
  description,
  language,
  image_url,
  copyright,
  feed_type,
  feed_version
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type CreateFeedParams struct {
	Uuid        string  `json:"uuid"`
	Url         string  `json:"url"`
	Link        *string `json:"link"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Language    *string `json:"language"`
	ImageUrl    *string `json:"image_url"`
	Copyright   *string `json:"copyright"`
	FeedType    *string `json:"feed_type"`
	FeedVersion *string `json:"feed_version"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.Uuid,
		arg.Url,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Language,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeedItem = `-- name: CreateFeedItem :exec
INSERT INTO feed_items (
  feed_id,
  item_id
) VALUES (
  ?, ?
)
ON CONFLICT(feed_id, item_id) DO NOTHING
`

type CreateFeedItemParams struct {
	FeedID string `json:"feed_id"`
	ItemID string `json:"item_id"`
}

func (q *Queries) CreateFeedItem(ctx context.Context, arg CreateFeedItemParams) error {
	_, err := q.db.ExecContext(ctx, createFeedItem, arg.FeedID, arg.ItemID)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
  id,
  url,
  title,
  content,
  description,
  author,
  published_at,
  image_url,
  guid
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(url) DO UPDATE SET
  title = excluded.title,
  content = excluded.content,
  description = excluded.description,
  author = excluded.author,
  published_at = excluded.published_at,
  image_url = excluded.image_url,
  guid = excluded.guid,
  updated_at = CURRENT_TIMESTAMP
RETURNING id, url, title, content, description, author, published_at, image_url, guid, created_at, updated_at
`

type CreateItemParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Content     *string `json:"content"`
	Description *string `json:"description"`
	Author      *string `json:"author"`
	PublishedAt *string `json:"published_at"`
	ImageUrl    *string `json:"image_url"`
	Guid        *string `json:"guid"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.ID,
		arg.Url,
		arg.Title,
		arg.Content,
		arg.Description,
		arg.Author,
		arg.PublishedAt,
		arg.ImageUrl,
		arg.Guid,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Content,
		&i.Description,
		&i.Author,
		&i.PublishedAt,
		&i.ImageUrl,
		&i.Guid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createItemEnclosure = `-- name: CreateItemEnclosure :exec
INSERT INTO item_enclosures (
  item_id,
  url,
  type,
  length
) VALUES (
  ?, ?, ?, ?
)
ON CONFLICT(item_id, url) DO NOTHING
`

type CreateItemEnclosureParams struct {
	ItemID string  `json:"item_id"`
	Url    string  `json:"url"`
	Type   *string `json:"type"`
	Length *string `json:"length"`
}

func (q *Queries) CreateItemEnclosure(ctx context.Context, arg CreateItemEnclosureParams) error {
	_, err := q.db.ExecContext(ctx, createItemEnclosure,
		arg.ItemID,
		arg.Url,
		arg.Type,
		arg.Length,
	)
	return err
}

const createItemRead = `-- name: CreateItemRead :exec
INSERT INTO item_reads (
  item_id
) VALUES (
  ?
)
ON CONFLICT(item_id) DO NOTHING
`

func (q *Queries) CreateItemRead(ctx context.Context, itemID string) error {
	_, err := q.db.ExecContext(ctx, createItemRead, itemID)
	return err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM
  feeds
WHERE
  uuid = ?
`

func (q *Queries) DeleteFeed(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, uuid)
	return err
}

const getFeed = `-- name: GetFeed :one
SELECT
  uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  uuid = ?
`

func (q *Queries) GetFeed(ctx context.Context, uuid string) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeed, uuid)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT
  i.id,
  i.url,
  i.title,
  i.content,
  i.description,
  i.author,
  i.published_at,
  i.image_url,
  i.guid,
  i.created_at,
  i.updated_at,
  fi.feed_id,
  COALESCE(ir.is_read, 0) AS is_read,
  CAST(COALESCE((SELECT GROUP_CONCAT(url) FROM item_enclosures WHERE item_id = i.id), '') AS TEXT) AS enclosures
FROM
  items i
  JOIN feed_items fi ON i.id = fi.item_id
  LEFT JOIN item_reads ir ON i.id = ir.item_id
WHERE
  i.id = ?
`

type GetItemRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Content     *string `json:"content"`
	Description *string `json:"description"`
	Author      *string `json:"author"`
	PublishedAt *string `json:"published_at"`
	ImageUrl    *string `json:"image_url"`
	Guid        *string `json:"guid"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
	Enclosures  string  `json:"enclosures"`
}

func (q *Queries) GetItem(ctx context.Context, id string) (GetItemRow, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i GetItemRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Content,
		&i.Description,
		&i.Author,
		&i.PublishedAt,
		&i.ImageUrl,
		&i.Guid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FeedID,
		&i.IsRead,
		&i.Enclosures,
	)
	return i, err
}

const listFeedItems = `-- name: ListFeedItems :many
SELECT
  i.id,
  i.url,
  i.title,
  -- i.content, -- Exclude content
  i.description,
  i.author,
  i.published_at,
  i.image_url,
  -- i.guid, -- Exclude guid
  i.created_at,
  i.updated_at,
  fi.feed_id,
  COALESCE(ir.is_read, 0) AS is_read
  -- Exclude enclosures
FROM
  items i
  JOIN feed_items fi ON i.id = fi.item_id
  LEFT JOIN item_reads ir ON i.id = ir.item_id
WHERE
  fi.feed_id = ?1
  AND (
    ?2 IS NULL
    OR i.published_at < ?2
    OR (
      i.published_at = ?2
      AND i.id < ?3
    )
  )
  AND (
    ?4 = 0
    OR COALESCE(ir.is_read, 0) = 0
  )
ORDER BY
  i.published_at DESC, i.id DESC
LIMIT ?5
`

type ListFeedItemsParams struct {
	FeedID            string      `json:"feed_id"`
	CursorPublishedAt interface{} `json:"cursor_published_at"`
	CursorID          *string     `json:"cursor_id"`
	FilterUnread      interface{} `json:"filter_unread"`
	Limit             int64       `json:"limit"`
}

type ListFeedItemsRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Author      *string `json:"author"`
	PublishedAt *string `json:"published_at"`
	ImageUrl    *string `json:"image_url"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) ListFeedItems(ctx context.Context, arg ListFeedItemsParams) ([]ListFeedItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeedItems,
		arg.FeedID,
		arg.CursorPublishedAt,
		arg.CursorID,
		arg.FilterUnread,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedItemsRow
	for rows.Next() {
		var i ListFeedItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Author,
			&i.PublishedAt,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FeedID,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
SELECT
  uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
ORDER BY
  created_at DESC
`

func (q *Queries) ListFeeds(ctx context.Context) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, listFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.Uuid,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGlobalItems = `-- name: ListGlobalItems :many
SELECT
  i.id,
  i.url,
  i.title,
  -- i.content, -- Exclude content for list view
  i.description,
  i.author,
  i.published_at,
  i.image_url,
  -- i.guid, -- Exclude guid for list view if not needed
  i.created_at,
  i.updated_at,
  fi.feed_id,
  COALESCE(ir.is_read, 0) AS is_read
  -- Exclude enclosures for list view
FROM
  items i
  JOIN feed_items fi ON i.id = fi.item_id
  LEFT JOIN item_reads ir ON i.id = ir.item_id
WHERE
  (
    ?1 IS NULL
    OR i.published_at < ?1
    OR (
      i.published_at = ?1
      AND i.id < ?2
    )
  )
  AND (
    ?3 = 0
    OR COALESCE(ir.is_read, 0) = 0
  )
ORDER BY
  i.published_at DESC, i.id DESC
LIMIT ?4
`

type ListGlobalItemsParams struct {
	CursorPublishedAt interface{} `json:"cursor_published_at"`
	CursorID          *string     `json:"cursor_id"`
	FilterUnread      interface{} `json:"filter_unread"`
	Limit             int64       `json:"limit"`
}

type ListGlobalItemsRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Author      *string `json:"author"`
	PublishedAt *string `json:"published_at"`
	ImageUrl    *string `json:"image_url"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) ListGlobalItems(ctx context.Context, arg ListGlobalItemsParams) ([]ListGlobalItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGlobalItems,
		arg.CursorPublishedAt,
		arg.CursorID,
		arg.FilterUnread,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGlobalItemsRow
	for rows.Next() {
		var i ListGlobalItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Author,
			&i.PublishedAt,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FeedID,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markItemRead = `-- name: MarkItemRead :one
INSERT INTO item_reads (
  item_id,
  is_read,
  read_at,
  updated_at
) VALUES (
  ?, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
ON CONFLICT(item_id) DO UPDATE SET
  is_read = 1,
  read_at = CURRENT_TIMESTAMP,
  updated_at = CURRENT_TIMESTAMP
RETURNING item_id, is_read, read_at, created_at, updated_at
`

func (q *Queries) MarkItemRead(ctx context.Context, itemID string) (ItemRead, error) {
	row := q.db.QueryRowContext(ctx, markItemRead, itemID)
	var i ItemRead
	err := row.Scan(
		&i.ItemID,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFeed = `-- name: UpdateFeed :one
UPDATE
  feeds
SET
  link = ?,
  title = ?,
  description = ?,
  language = ?,
  image_url = ?,
  copyright = ?,
  feed_type = ?,
  feed_version = ?,
  last_fetched_at = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  uuid = ?
RETURNING uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type UpdateFeedParams struct {
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Language      *string `json:"language"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	LastFetchedAt *string `json:"last_fetched_at"`
	Uuid          string  `json:"uuid"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, updateFeed,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Language,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
		arg.LastFetchedAt,
		arg.Uuid,
	)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
