// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"
	"strings"
)

const countFeedsPerTag = `-- name: CountFeedsPerTag :many
SELECT
  ft.tag_id,
  COUNT(DISTINCT ft.feed_id) AS count
FROM
  feed_tags ft
GROUP BY
  ft.tag_id
`

type CountFeedsPerTagRow struct {
	TagID string `json:"tag_id"`
	Count int64  `json:"count"`
}

func (q *Queries) CountFeedsPerTag(ctx context.Context) ([]CountFeedsPerTagRow, error) {
	rows, err := q.db.QueryContext(ctx, countFeedsPerTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountFeedsPerTagRow
	for rows.Next() {
		var i CountFeedsPerTagRow
		if err := rows.Scan(&i.TagID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countItems = `-- name: CountItems :one
SELECT
  COUNT(DISTINCT i.id)
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = fi.feed_id AND ft.tag_id = ?3
  )) AND
  (?4 IS NULL OR i.created_at >= ?4)
`

type CountItemsParams struct {
	FeedID interface{} `json:"feed_id"`
	IsRead interface{} `json:"is_read"`
	TagID  interface{} `json:"tag_id"`
	Since  interface{} `json:"since"`
}

func (q *Queries) CountItems(ctx context.Context, arg CountItemsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countItems,
		arg.FeedID,
		arg.IsRead,
		arg.TagID,
		arg.Since,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalUnreadItems = `-- name: CountTotalUnreadItems :one
SELECT
  COUNT(DISTINCT fi.item_id) AS count
FROM
  feed_items fi
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0
`

func (q *Queries) CountTotalUnreadItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTotalUnreadItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadItemsPerFeed = `-- name: CountUnreadItemsPerFeed :many
SELECT
  fi.feed_id,
  COUNT(*) AS count
FROM
  feed_items fi
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0
GROUP BY
  fi.feed_id
`

type CountUnreadItemsPerFeedRow struct {
	FeedID string `json:"feed_id"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountUnreadItemsPerFeed(ctx context.Context) ([]CountUnreadItemsPerFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, countUnreadItemsPerFeed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUnreadItemsPerFeedRow
	for rows.Next() {
		var i CountUnreadItemsPerFeedRow
		if err := rows.Scan(&i.FeedID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUnreadItemsPerTag = `-- name: CountUnreadItemsPerTag :many
SELECT
  ft.tag_id,
  COUNT(DISTINCT fi.item_id) AS count
FROM
  feed_tags ft
JOIN
  feed_items fi ON ft.feed_id = fi.feed_id
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0
GROUP BY
  ft.tag_id
`

type CountUnreadItemsPerTagRow struct {
	TagID string `json:"tag_id"`
	Count int64  `json:"count"`
}

func (q *Queries) CountUnreadItemsPerTag(ctx context.Context) ([]CountUnreadItemsPerTagRow, error) {
	rows, err := q.db.QueryContext(ctx, countUnreadItemsPerTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUnreadItemsPerTagRow
	for rows.Next() {
		var i CountUnreadItemsPerTagRow
		if err := rows.Scan(&i.TagID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds (
  id,
  url,
  link,
  title,
  description,
  lang,
  image_url,
  copyright,
  feed_type,
  feed_version
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type CreateFeedParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Link        *string `json:"link"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Lang        *string `json:"lang"`
	ImageUrl    *string `json:"image_url"`
	Copyright   *string `json:"copyright"`
	FeedType    *string `json:"feed_type"`
	FeedVersion *string `json:"feed_version"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.ID,
		arg.Url,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Lang,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeedItem = `-- name: CreateFeedItem :exec
INSERT INTO feed_items (
  feed_id,
  item_id
) VALUES (
  ?, ?
)
ON CONFLICT(feed_id, item_id) DO NOTHING
`

type CreateFeedItemParams struct {
	FeedID string `json:"feed_id"`
	ItemID string `json:"item_id"`
}

func (q *Queries) CreateFeedItem(ctx context.Context, arg CreateFeedItemParams) error {
	_, err := q.db.ExecContext(ctx, createFeedItem, arg.FeedID, arg.ItemID)
	return err
}

const createFeedTag = `-- name: CreateFeedTag :exec
INSERT INTO feed_tags (
  feed_id,
  tag_id
) VALUES (
  ?, ?
)
ON CONFLICT(feed_id, tag_id) DO NOTHING
`

type CreateFeedTagParams struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) CreateFeedTag(ctx context.Context, arg CreateFeedTagParams) error {
	_, err := q.db.ExecContext(ctx, createFeedTag, arg.FeedID, arg.TagID)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
  id,
  url,
  title,
  description,
  published_at,
  author,
  guid,
  content,
  image_url,
  categories
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(url) DO NOTHING
RETURNING id, url, title, description, published_at, author, guid, content, image_url, categories, created_at, updated_at
`

type CreateItemParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.ID,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.PublishedAt,
		arg.Author,
		arg.Guid,
		arg.Content,
		arg.ImageUrl,
		arg.Categories,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.Guid,
		&i.Content,
		&i.ImageUrl,
		&i.Categories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createItemRead = `-- name: CreateItemRead :exec
INSERT INTO item_reads (
  item_id
) VALUES (
  ?
)
ON CONFLICT(item_id) DO NOTHING
`

func (q *Queries) CreateItemRead(ctx context.Context, itemID string) error {
	_, err := q.db.ExecContext(ctx, createItemRead, itemID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (
  id,
  name
) VALUES (
  ?, ?
)
RETURNING id, name, created_at, updated_at
`

type CreateTagParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, arg.ID, arg.Name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM
  feeds
WHERE
  id = ?
`

func (q *Queries) DeleteFeed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, id)
	return err
}

const deleteFeedFetcherCache = `-- name: DeleteFeedFetcherCache :exec
DELETE FROM
  feed_fetcher_cache
WHERE
  feed_id = ?
`

func (q *Queries) DeleteFeedFetcherCache(ctx context.Context, feedID string) error {
	_, err := q.db.ExecContext(ctx, deleteFeedFetcherCache, feedID)
	return err
}

const deleteFeedTag = `-- name: DeleteFeedTag :exec
DELETE FROM
  feed_tags
WHERE
  feed_id = ? AND tag_id = ?
`

type DeleteFeedTagParams struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) DeleteFeedTag(ctx context.Context, arg DeleteFeedTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteFeedTag, arg.FeedID, arg.TagID)
	return err
}

const deleteFeedTags = `-- name: DeleteFeedTags :exec
DELETE FROM
  feed_tags
WHERE
  feed_id = ?
`

func (q *Queries) DeleteFeedTags(ctx context.Context, feedID string) error {
	_, err := q.db.ExecContext(ctx, deleteFeedTags, feedID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM
  tags
WHERE
  id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const getFeed = `-- name: GetFeed :one
SELECT
  id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  id = ?
`

func (q *Queries) GetFeed(ctx context.Context, id string) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeed, id)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFeedByURL = `-- name: GetFeedByURL :one
SELECT
  id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  url = ?
`

func (q *Queries) GetFeedByURL(ctx context.Context, url string) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeedByURL, url)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFeedFetcherCache = `-- name: GetFeedFetcherCache :one
SELECT
  feed_id, etag, last_modified, created_at, updated_at
FROM
  feed_fetcher_cache
WHERE
  feed_id = ?
`

func (q *Queries) GetFeedFetcherCache(ctx context.Context, feedID string) (FeedFetcherCache, error) {
	row := q.db.QueryRowContext(ctx, getFeedFetcherCache, feedID)
	var i FeedFetcherCache
	err := row.Scan(
		&i.FeedID,
		&i.Etag,
		&i.LastModified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT
  i.id,
  i.url,
  i.title,
  i.description,
  i.published_at,
  i.author,
  i.guid,
  i.content,
  i.image_url,
  i.categories,
  i.created_at,
  fi.feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
WHERE
  i.id = ?
`

type GetItemRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
	CreatedAt   string  `json:"created_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) GetItem(ctx context.Context, id string) (GetItemRow, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i GetItemRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.Guid,
		&i.Content,
		&i.ImageUrl,
		&i.Categories,
		&i.CreatedAt,
		&i.FeedID,
		&i.IsRead,
	)
	return i, err
}

const listFeedTags = `-- name: ListFeedTags :many
SELECT
  feed_id,
  tag_id
FROM
  feed_tags
WHERE
  (?1 IS NULL OR feed_id = ?1)
  AND (?2 IS NULL OR tag_id = ?2)
`

type ListFeedTagsParams struct {
	FeedID interface{} `json:"feed_id"`
	TagID  interface{} `json:"tag_id"`
}

type ListFeedTagsRow struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) ListFeedTags(ctx context.Context, arg ListFeedTagsParams) ([]ListFeedTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeedTags, arg.FeedID, arg.TagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedTagsRow
	for rows.Next() {
		var i ListFeedTagsRow
		if err := rows.Scan(&i.FeedID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.last_fetched_at, f.created_at, f.updated_at
FROM
  feeds f
WHERE
  (?1 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = f.id AND ft.tag_id = ?1
  ))
ORDER BY
  updated_at ASC
`

func (q *Queries) ListFeeds(ctx context.Context, tagID interface{}) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, listFeeds, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Lang,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedsByIDs = `-- name: ListFeedsByIDs :many
SELECT
  id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  id IN (/*SLICE:ids*/?)
`

func (q *Queries) ListFeedsByIDs(ctx context.Context, ids []string) ([]Feed, error) {
	query := listFeedsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Lang,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItems = `-- name: ListItems :many
SELECT
  i.id,
  i.url,
  i.title,
  CAST(COALESCE(SUBSTR(i.description, 1, 140), '') AS TEXT) AS description,
  i.published_at,
  i.author,
  i.guid,
  i.content,
  i.image_url,
  i.categories,
  i.created_at,
  CAST(MIN(fi.feed_id) AS TEXT) AS feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = fi.feed_id AND ft.tag_id = ?3
  )) AND
  (?4 IS NULL OR i.created_at >= ?4)
GROUP BY
  i.id
ORDER BY
  i.created_at ASC
LIMIT ?6 OFFSET ?5
`

type ListItemsParams struct {
	FeedID interface{} `json:"feed_id"`
	IsRead interface{} `json:"is_read"`
	TagID  interface{} `json:"tag_id"`
	Since  interface{} `json:"since"`
	Offset int64       `json:"offset"`
	Limit  int64       `json:"limit"`
}

type ListItemsRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description string  `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
	CreatedAt   string  `json:"created_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems,
		arg.FeedID,
		arg.IsRead,
		arg.TagID,
		arg.Since,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.Guid,
			&i.Content,
			&i.ImageUrl,
			&i.Categories,
			&i.CreatedAt,
			&i.FeedID,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT
  id, name, created_at, updated_at
FROM
  tags
ORDER BY
  updated_at ASC
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByFeedId = `-- name: ListTagsByFeedId :many
SELECT
  t.id, t.name, t.created_at, t.updated_at
FROM
  tags t
JOIN
  feed_tags ft ON t.id = ft.tag_id
WHERE
  ft.feed_id = ?
ORDER BY
  t.name ASC
`

func (q *Queries) ListTagsByFeedId(ctx context.Context, feedID string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByFeedId, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedFetched = `-- name: MarkFeedFetched :exec
UPDATE
  feeds
SET
  last_fetched_at = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  id = ?
`

type MarkFeedFetchedParams struct {
	LastFetchedAt *string `json:"last_fetched_at"`
	ID            string  `json:"id"`
}

func (q *Queries) MarkFeedFetched(ctx context.Context, arg MarkFeedFetchedParams) error {
	_, err := q.db.ExecContext(ctx, markFeedFetched, arg.LastFetchedAt, arg.ID)
	return err
}

const setItemRead = `-- name: SetItemRead :one
INSERT INTO item_reads (
  item_id,
  is_read,
  read_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(item_id) DO UPDATE SET
  is_read = excluded.is_read,
  read_at = excluded.read_at,
  updated_at = CURRENT_TIMESTAMP
RETURNING item_id, is_read, read_at, created_at, updated_at
`

type SetItemReadParams struct {
	ItemID string  `json:"item_id"`
	IsRead int64   `json:"is_read"`
	ReadAt *string `json:"read_at"`
}

func (q *Queries) SetItemRead(ctx context.Context, arg SetItemReadParams) (ItemRead, error) {
	row := q.db.QueryRowContext(ctx, setItemRead, arg.ItemID, arg.IsRead, arg.ReadAt)
	var i ItemRead
	err := row.Scan(
		&i.ItemID,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFeed = `-- name: UpdateFeed :one
UPDATE
  feeds
SET
  link = ?,
  title = ?,
  description = ?,
  lang = ?,
  image_url = ?,
  copyright = ?,
  feed_type = ?,
  feed_version = ?,
  last_fetched_at = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  id = ?
RETURNING id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type UpdateFeedParams struct {
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	LastFetchedAt *string `json:"last_fetched_at"`
	ID            string  `json:"id"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, updateFeed,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Lang,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
		arg.LastFetchedAt,
		arg.ID,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFeedFetcherCache = `-- name: UpsertFeedFetcherCache :one
INSERT INTO feed_fetcher_cache (
  feed_id,
  etag,
  last_modified
) VALUES (
  ?, ?, ?
)
ON CONFLICT(feed_id) DO UPDATE SET
  etag = excluded.etag,
  last_modified = excluded.last_modified,
  updated_at = CURRENT_TIMESTAMP
RETURNING feed_id, etag, last_modified, created_at, updated_at
`

type UpsertFeedFetcherCacheParams struct {
	FeedID       string  `json:"feed_id"`
	Etag         *string `json:"etag"`
	LastModified *string `json:"last_modified"`
}

func (q *Queries) UpsertFeedFetcherCache(ctx context.Context, arg UpsertFeedFetcherCacheParams) (FeedFetcherCache, error) {
	row := q.db.QueryRowContext(ctx, upsertFeedFetcherCache, arg.FeedID, arg.Etag, arg.LastModified)
	var i FeedFetcherCache
	err := row.Scan(
		&i.FeedID,
		&i.Etag,
		&i.LastModified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
