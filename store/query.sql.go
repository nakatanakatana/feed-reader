// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"
	"strings"
)

const countItems = `-- name: CountItems :one
SELECT
  COUNT(*)
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_saves isv ON i.id = isv.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR COALESCE(isv.is_saved, 0) = ?3)
`

type CountItemsParams struct {
	FeedID  interface{} `json:"feed_id"`
	IsRead  interface{} `json:"is_read"`
	IsSaved interface{} `json:"is_saved"`
}

func (q *Queries) CountItems(ctx context.Context, arg CountItemsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countItems, arg.FeedID, arg.IsRead, arg.IsSaved)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds (
  uuid,
  url,
  link,
  title,
  description,
  language,
  image_url,
  copyright,
  feed_type,
  feed_version
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type CreateFeedParams struct {
	Uuid        string  `json:"uuid"`
	Url         string  `json:"url"`
	Link        *string `json:"link"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Language    *string `json:"language"`
	ImageUrl    *string `json:"image_url"`
	Copyright   *string `json:"copyright"`
	FeedType    *string `json:"feed_type"`
	FeedVersion *string `json:"feed_version"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.Uuid,
		arg.Url,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Language,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeedItem = `-- name: CreateFeedItem :exec
INSERT INTO feed_items (
  feed_id,
  item_id
) VALUES (
  ?, ?
)
ON CONFLICT(feed_id, item_id) DO NOTHING
`

type CreateFeedItemParams struct {
	FeedID string `json:"feed_id"`
	ItemID string `json:"item_id"`
}

func (q *Queries) CreateFeedItem(ctx context.Context, arg CreateFeedItemParams) error {
	_, err := q.db.ExecContext(ctx, createFeedItem, arg.FeedID, arg.ItemID)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
  id,
  url,
  title,
  description,
  published_at,
  author,
  guid
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(url) DO UPDATE SET
  title = excluded.title,
  description = excluded.description,
  published_at = excluded.published_at,
  author = excluded.author,
  guid = excluded.guid,
  updated_at = CURRENT_TIMESTAMP
RETURNING id, url, title, description, published_at, author, guid, created_at, updated_at
`

type CreateItemParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.ID,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.PublishedAt,
		arg.Author,
		arg.Guid,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.Guid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createItemRead = `-- name: CreateItemRead :exec
INSERT INTO item_reads (
  item_id
) VALUES (
  ?
)
ON CONFLICT(item_id) DO NOTHING
`

func (q *Queries) CreateItemRead(ctx context.Context, itemID string) error {
	_, err := q.db.ExecContext(ctx, createItemRead, itemID)
	return err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM
  feeds
WHERE
  uuid = ?
`

func (q *Queries) DeleteFeed(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, uuid)
	return err
}

const getFeed = `-- name: GetFeed :one
SELECT
  uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  uuid = ?
`

func (q *Queries) GetFeed(ctx context.Context, uuid string) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeed, uuid)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT
  i.id,
  i.url,
  i.title,
  i.description,
  i.published_at,
  i.author,
  fi.feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read,
  CAST(COALESCE(isv.is_saved, 0) AS INTEGER) AS is_saved
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_saves isv ON i.id = isv.item_id
WHERE
  i.id = ?
`

type GetItemRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
	IsSaved     int64   `json:"is_saved"`
}

func (q *Queries) GetItem(ctx context.Context, id string) (GetItemRow, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i GetItemRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.FeedID,
		&i.IsRead,
		&i.IsSaved,
	)
	return i, err
}

const listFeeds = `-- name: ListFeeds :many
SELECT
  uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
ORDER BY
  created_at DESC
`

func (q *Queries) ListFeeds(ctx context.Context) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, listFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.Uuid,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedsByUUIDs = `-- name: ListFeedsByUUIDs :many
SELECT
  uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
FROM
  feeds
WHERE
  uuid IN (/*SLICE:uuids*/?)
`

func (q *Queries) ListFeedsByUUIDs(ctx context.Context, uuids []string) ([]Feed, error) {
	query := listFeedsByUUIDs
	var queryParams []interface{}
	if len(uuids) > 0 {
		for _, v := range uuids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:uuids*/?", strings.Repeat(",?", len(uuids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:uuids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.Uuid,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItems = `-- name: ListItems :many
SELECT
  i.id,
  i.url,
  i.title,
  i.description,
  i.published_at,
  i.author,
  fi.feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read,
  CAST(COALESCE(isv.is_saved, 0) AS INTEGER) AS is_saved
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_saves isv ON i.id = isv.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR COALESCE(isv.is_saved, 0) = ?3)
ORDER BY
  i.published_at DESC
LIMIT ?5 OFFSET ?4
`

type ListItemsParams struct {
	FeedID  interface{} `json:"feed_id"`
	IsRead  interface{} `json:"is_read"`
	IsSaved interface{} `json:"is_saved"`
	Offset  int64       `json:"offset"`
	Limit   int64       `json:"limit"`
}

type ListItemsRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
	IsSaved     int64   `json:"is_saved"`
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems,
		arg.FeedID,
		arg.IsRead,
		arg.IsSaved,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.FeedID,
			&i.IsRead,
			&i.IsSaved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsAsc = `-- name: ListItemsAsc :many
SELECT
  i.id,
  i.url,
  i.title,
  i.description,
  i.published_at,
  i.author,
  fi.feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read,
  CAST(COALESCE(isv.is_saved, 0) AS INTEGER) AS is_saved
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_saves isv ON i.id = isv.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR COALESCE(isv.is_saved, 0) = ?3)
ORDER BY
  i.published_at ASC
LIMIT ?5 OFFSET ?4
`

type ListItemsAscParams struct {
	FeedID  interface{} `json:"feed_id"`
	IsRead  interface{} `json:"is_read"`
	IsSaved interface{} `json:"is_saved"`
	Offset  int64       `json:"offset"`
	Limit   int64       `json:"limit"`
}

type ListItemsAscRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
	IsSaved     int64   `json:"is_saved"`
}

func (q *Queries) ListItemsAsc(ctx context.Context, arg ListItemsAscParams) ([]ListItemsAscRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemsAsc,
		arg.FeedID,
		arg.IsRead,
		arg.IsSaved,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsAscRow
	for rows.Next() {
		var i ListItemsAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.FeedID,
			&i.IsRead,
			&i.IsSaved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByFeed = `-- name: ListItemsByFeed :many
SELECT
  i.id, i.url, i.title, i.description, i.published_at, i.author, i.guid, i.created_at, i.updated_at
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
WHERE
  fi.feed_id = ?
ORDER BY
  i.published_at DESC
`

func (q *Queries) ListItemsByFeed(ctx context.Context, feedID string) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, listItemsByFeed, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.Guid,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedFetched = `-- name: MarkFeedFetched :exec
UPDATE
  feeds
SET
  last_fetched_at = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  uuid = ?
`

type MarkFeedFetchedParams struct {
	LastFetchedAt *string `json:"last_fetched_at"`
	Uuid          string  `json:"uuid"`
}

func (q *Queries) MarkFeedFetched(ctx context.Context, arg MarkFeedFetchedParams) error {
	_, err := q.db.ExecContext(ctx, markFeedFetched, arg.LastFetchedAt, arg.Uuid)
	return err
}

const setItemRead = `-- name: SetItemRead :one
INSERT INTO item_reads (
  item_id,
  is_read,
  read_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(item_id) DO UPDATE SET
  is_read = excluded.is_read,
  read_at = excluded.read_at,
  updated_at = CURRENT_TIMESTAMP
RETURNING item_id, is_read, read_at, created_at, updated_at
`

type SetItemReadParams struct {
	ItemID string  `json:"item_id"`
	IsRead int64   `json:"is_read"`
	ReadAt *string `json:"read_at"`
}

func (q *Queries) SetItemRead(ctx context.Context, arg SetItemReadParams) (ItemRead, error) {
	row := q.db.QueryRowContext(ctx, setItemRead, arg.ItemID, arg.IsRead, arg.ReadAt)
	var i ItemRead
	err := row.Scan(
		&i.ItemID,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setItemSaved = `-- name: SetItemSaved :one
INSERT INTO item_saves (
  item_id,
  is_saved,
  saved_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(item_id) DO UPDATE SET
  is_saved = excluded.is_saved,
  saved_at = excluded.saved_at,
  updated_at = CURRENT_TIMESTAMP
RETURNING item_id, is_saved, saved_at, created_at, updated_at
`

type SetItemSavedParams struct {
	ItemID  string  `json:"item_id"`
	IsSaved int64   `json:"is_saved"`
	SavedAt *string `json:"saved_at"`
}

func (q *Queries) SetItemSaved(ctx context.Context, arg SetItemSavedParams) (ItemSafe, error) {
	row := q.db.QueryRowContext(ctx, setItemSaved, arg.ItemID, arg.IsSaved, arg.SavedAt)
	var i ItemSafe
	err := row.Scan(
		&i.ItemID,
		&i.IsSaved,
		&i.SavedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFeed = `-- name: UpdateFeed :one
UPDATE
  feeds
SET
  link = ?,
  title = ?,
  description = ?,
  language = ?,
  image_url = ?,
  copyright = ?,
  feed_type = ?,
  feed_version = ?,
  last_fetched_at = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  uuid = ?
RETURNING uuid, url, link, title, description, language, image_url, copyright, feed_type, feed_version, last_fetched_at, created_at, updated_at
`

type UpdateFeedParams struct {
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Language      *string `json:"language"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	LastFetchedAt *string `json:"last_fetched_at"`
	Uuid          string  `json:"uuid"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, updateFeed,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Language,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
		arg.LastFetchedAt,
		arg.Uuid,
	)
	var i Feed
	err := row.Scan(
		&i.Uuid,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
