// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"
	"strings"
)

const countFeedsPerTag = `-- name: CountFeedsPerTag :many
SELECT
  ft.tag_id,
  COUNT(DISTINCT ft.feed_id) AS count
FROM
  feed_tags ft
GROUP BY
  ft.tag_id
`

type CountFeedsPerTagRow struct {
	TagID string `json:"tag_id"`
	Count int64  `json:"count"`
}

func (q *Queries) CountFeedsPerTag(ctx context.Context) ([]CountFeedsPerTagRow, error) {
	rows, err := q.db.QueryContext(ctx, countFeedsPerTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountFeedsPerTagRow
	for rows.Next() {
		var i CountFeedsPerTagRow
		if err := rows.Scan(&i.TagID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countItems = `-- name: CountItems :one
SELECT
  COUNT(DISTINCT i.id)
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_blocks ib ON i.id = ib.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = fi.feed_id AND ft.tag_id = ?3
  )) AND
  (?4 IS NULL OR i.created_at >= ?4) AND
  (?5 IS NULL OR (CASE WHEN ib.item_id IS NOT NULL THEN 1 ELSE 0 END = ?5))
`

type CountItemsParams struct {
	FeedID    interface{} `json:"feed_id"`
	IsRead    interface{} `json:"is_read"`
	TagID     interface{} `json:"tag_id"`
	Since     interface{} `json:"since"`
	IsBlocked interface{} `json:"is_blocked"`
}

func (q *Queries) CountItems(ctx context.Context, arg CountItemsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countItems,
		arg.FeedID,
		arg.IsRead,
		arg.TagID,
		arg.Since,
		arg.IsBlocked,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalUnreadItems = `-- name: CountTotalUnreadItems :one
SELECT
  COUNT(DISTINCT fi.item_id) AS count
FROM
  feed_items fi
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0 AND
  NOT EXISTS (SELECT 1 FROM item_blocks ib WHERE ib.item_id = fi.item_id)
`

func (q *Queries) CountTotalUnreadItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTotalUnreadItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadItemsPerFeed = `-- name: CountUnreadItemsPerFeed :many
SELECT
  fi.feed_id,
  COUNT(DISTINCT fi.item_id) AS count
FROM
  feed_items fi
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0 AND
  NOT EXISTS (SELECT 1 FROM item_blocks ib WHERE ib.item_id = fi.item_id)
GROUP BY
  fi.feed_id
`

type CountUnreadItemsPerFeedRow struct {
	FeedID string `json:"feed_id"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountUnreadItemsPerFeed(ctx context.Context) ([]CountUnreadItemsPerFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, countUnreadItemsPerFeed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUnreadItemsPerFeedRow
	for rows.Next() {
		var i CountUnreadItemsPerFeedRow
		if err := rows.Scan(&i.FeedID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUnreadItemsPerTag = `-- name: CountUnreadItemsPerTag :many
SELECT
  ft.tag_id,
  COUNT(DISTINCT fi.item_id) AS count
FROM
  feed_tags ft
JOIN
  feed_items fi ON ft.feed_id = fi.feed_id
LEFT JOIN
  item_reads ir ON fi.item_id = ir.item_id
WHERE
  COALESCE(ir.is_read, 0) = 0 AND
  NOT EXISTS (SELECT 1 FROM item_blocks ib WHERE ib.item_id = fi.item_id)
GROUP BY
  ft.tag_id
`

type CountUnreadItemsPerTagRow struct {
	TagID string `json:"tag_id"`
	Count int64  `json:"count"`
}

func (q *Queries) CountUnreadItemsPerTag(ctx context.Context) ([]CountUnreadItemsPerTagRow, error) {
	rows, err := q.db.QueryContext(ctx, countUnreadItemsPerTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUnreadItemsPerTagRow
	for rows.Next() {
		var i CountUnreadItemsPerTagRow
		if err := rows.Scan(&i.TagID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds (
  id,
  url,
  link,
  title,
  description,
  lang,
  image_url,
  copyright,
  feed_type,
  feed_version
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, created_at, updated_at
`

type CreateFeedParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Link        *string `json:"link"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Lang        *string `json:"lang"`
	ImageUrl    *string `json:"image_url"`
	Copyright   *string `json:"copyright"`
	FeedType    *string `json:"feed_type"`
	FeedVersion *string `json:"feed_version"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.ID,
		arg.Url,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Lang,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeedItem = `-- name: CreateFeedItem :exec
INSERT INTO feed_items (
  feed_id,
  item_id,
  published_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(feed_id, item_id) DO UPDATE SET
  published_at = excluded.published_at,
  updated_at = (strftime('%FT%TZ', 'now'))
`

type CreateFeedItemParams struct {
	FeedID      string  `json:"feed_id"`
	ItemID      string  `json:"item_id"`
	PublishedAt *string `json:"published_at"`
}

func (q *Queries) CreateFeedItem(ctx context.Context, arg CreateFeedItemParams) error {
	_, err := q.db.ExecContext(ctx, createFeedItem, arg.FeedID, arg.ItemID, arg.PublishedAt)
	return err
}

const createFeedTag = `-- name: CreateFeedTag :exec
INSERT INTO feed_tags (
  feed_id,
  tag_id
) VALUES (
  ?, ?
)
ON CONFLICT(feed_id, tag_id) DO NOTHING
`

type CreateFeedTagParams struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) CreateFeedTag(ctx context.Context, arg CreateFeedTagParams) error {
	_, err := q.db.ExecContext(ctx, createFeedTag, arg.FeedID, arg.TagID)
	return err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
  id,
  url,
  title,
  description,
  published_at,
  author,
  guid,
  content,
  image_url,
  categories
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(url) DO UPDATE SET
  title = excluded.title,
  description = excluded.description,
  author = excluded.author,
  guid = excluded.guid,
  content = excluded.content,
  image_url = excluded.image_url,
  categories = excluded.categories,
  updated_at = (strftime('%FT%TZ', 'now'))
RETURNING id, url, title, description, published_at, author, guid, content, image_url, categories, created_at, updated_at
`

type CreateItemParams struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.ID,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.PublishedAt,
		arg.Author,
		arg.Guid,
		arg.Content,
		arg.ImageUrl,
		arg.Categories,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.Guid,
		&i.Content,
		&i.ImageUrl,
		&i.Categories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createItemBlock = `-- name: CreateItemBlock :exec
INSERT INTO item_blocks (
  item_id,
  rule_id
) VALUES (
  ?, ?
)
ON CONFLICT(item_id, rule_id) DO NOTHING
`

type CreateItemBlockParams struct {
	ItemID string `json:"item_id"`
	RuleID string `json:"rule_id"`
}

func (q *Queries) CreateItemBlock(ctx context.Context, arg CreateItemBlockParams) error {
	_, err := q.db.ExecContext(ctx, createItemBlock, arg.ItemID, arg.RuleID)
	return err
}

const createItemBlockRule = `-- name: CreateItemBlockRule :one
INSERT INTO item_block_rules (
  id,
  rule_type,
  rule_value,
  domain
) VALUES (
  ?, ?, ?, ?
)
RETURNING id, rule_type, rule_value, domain, created_at, updated_at
`

type CreateItemBlockRuleParams struct {
	ID        string `json:"id"`
	RuleType  string `json:"rule_type"`
	RuleValue string `json:"rule_value"`
	Domain    string `json:"domain"`
}

func (q *Queries) CreateItemBlockRule(ctx context.Context, arg CreateItemBlockRuleParams) (ItemBlockRule, error) {
	row := q.db.QueryRowContext(ctx, createItemBlockRule,
		arg.ID,
		arg.RuleType,
		arg.RuleValue,
		arg.Domain,
	)
	var i ItemBlockRule
	err := row.Scan(
		&i.ID,
		&i.RuleType,
		&i.RuleValue,
		&i.Domain,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createItemRead = `-- name: CreateItemRead :exec
INSERT INTO item_reads (
  item_id
) VALUES (
  ?
)
ON CONFLICT(item_id) DO NOTHING
`

func (q *Queries) CreateItemRead(ctx context.Context, itemID string) error {
	_, err := q.db.ExecContext(ctx, createItemRead, itemID)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (
  id,
  name
) VALUES (
  ?, ?
)
ON CONFLICT(name) DO UPDATE SET
  name = excluded.name
RETURNING id, name, created_at, updated_at
`

type CreateTagParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, arg.ID, arg.Name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createURLParsingRule = `-- name: CreateURLParsingRule :one
INSERT INTO url_parsing_rules (
  id,
  domain,
  rule_type,
  pattern
) VALUES (
  ?, ?, ?, ?
)
RETURNING id, domain, rule_type, pattern, created_at, updated_at
`

type CreateURLParsingRuleParams struct {
	ID       string `json:"id"`
	Domain   string `json:"domain"`
	RuleType string `json:"rule_type"`
	Pattern  string `json:"pattern"`
}

func (q *Queries) CreateURLParsingRule(ctx context.Context, arg CreateURLParsingRuleParams) (UrlParsingRule, error) {
	row := q.db.QueryRowContext(ctx, createURLParsingRule,
		arg.ID,
		arg.Domain,
		arg.RuleType,
		arg.Pattern,
	)
	var i UrlParsingRule
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RuleType,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM
  feeds
WHERE
  id = ?
`

func (q *Queries) DeleteFeed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, id)
	return err
}

const deleteFeedFetcher = `-- name: DeleteFeedFetcher :exec
DELETE FROM
  feed_fetcher
WHERE
  feed_id = ?
`

func (q *Queries) DeleteFeedFetcher(ctx context.Context, feedID string) error {
	_, err := q.db.ExecContext(ctx, deleteFeedFetcher, feedID)
	return err
}

const deleteFeedTag = `-- name: DeleteFeedTag :exec
DELETE FROM
  feed_tags
WHERE
  feed_id = ? AND tag_id = ?
`

type DeleteFeedTagParams struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) DeleteFeedTag(ctx context.Context, arg DeleteFeedTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteFeedTag, arg.FeedID, arg.TagID)
	return err
}

const deleteFeedTags = `-- name: DeleteFeedTags :exec
DELETE FROM
  feed_tags
WHERE
  feed_id = ?
`

func (q *Queries) DeleteFeedTags(ctx context.Context, feedID string) error {
	_, err := q.db.ExecContext(ctx, deleteFeedTags, feedID)
	return err
}

const deleteItemBlockRule = `-- name: DeleteItemBlockRule :exec
DELETE FROM
  item_block_rules
WHERE
  id = ?
`

func (q *Queries) DeleteItemBlockRule(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteItemBlockRule, id)
	return err
}

const deleteItemBlocksByRuleID = `-- name: DeleteItemBlocksByRuleID :exec
DELETE FROM
  item_blocks
WHERE
  rule_id = ?
`

func (q *Queries) DeleteItemBlocksByRuleID(ctx context.Context, ruleID string) error {
	_, err := q.db.ExecContext(ctx, deleteItemBlocksByRuleID, ruleID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM
  tags
WHERE
  id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const deleteURLParsingRule = `-- name: DeleteURLParsingRule :exec
DELETE FROM
  url_parsing_rules
WHERE
  id = ?
`

func (q *Queries) DeleteURLParsingRule(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteURLParsingRule, id)
	return err
}

const getFeed = `-- name: GetFeed :one
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.created_at, f.updated_at,
  ff.last_fetched_at,
  ff.next_fetch
FROM
  feeds f
LEFT JOIN
  feed_fetcher ff ON f.id = ff.feed_id
WHERE
  f.id = ?
`

type GetFeedRow struct {
	ID            string  `json:"id"`
	Url           string  `json:"url"`
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	CreatedAt     string  `json:"created_at"`
	UpdatedAt     string  `json:"updated_at"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) GetFeed(ctx context.Context, id string) (GetFeedRow, error) {
	row := q.db.QueryRowContext(ctx, getFeed, id)
	var i GetFeedRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastFetchedAt,
		&i.NextFetch,
	)
	return i, err
}

const getFeedByURL = `-- name: GetFeedByURL :one
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.created_at, f.updated_at,
  ff.last_fetched_at,
  ff.next_fetch
FROM
  feeds f
LEFT JOIN
  feed_fetcher ff ON f.id = ff.feed_id
WHERE
  f.url = ?
`

type GetFeedByURLRow struct {
	ID            string  `json:"id"`
	Url           string  `json:"url"`
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	CreatedAt     string  `json:"created_at"`
	UpdatedAt     string  `json:"updated_at"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) GetFeedByURL(ctx context.Context, url string) (GetFeedByURLRow, error) {
	row := q.db.QueryRowContext(ctx, getFeedByURL, url)
	var i GetFeedByURLRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastFetchedAt,
		&i.NextFetch,
	)
	return i, err
}

const getFeedFetcher = `-- name: GetFeedFetcher :one
SELECT
  feed_id, etag, last_modified, last_fetched_at, next_fetch, created_at, updated_at
FROM
  feed_fetcher
WHERE
  feed_id = ?
`

func (q *Queries) GetFeedFetcher(ctx context.Context, feedID string) (FeedFetcher, error) {
	row := q.db.QueryRowContext(ctx, getFeedFetcher, feedID)
	var i FeedFetcher
	err := row.Scan(
		&i.FeedID,
		&i.Etag,
		&i.LastModified,
		&i.LastFetchedAt,
		&i.NextFetch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItem = `-- name: GetItem :one
SELECT
  i.id,
  i.url,
  i.title,
  i.description,
  i.published_at,
  i.author,
  i.guid,
  i.content,
  i.image_url,
  i.categories,
  i.created_at,
  fi.feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
WHERE
  i.id = ?
`

type GetItemRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
	CreatedAt   string  `json:"created_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) GetItem(ctx context.Context, id string) (GetItemRow, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i GetItemRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.PublishedAt,
		&i.Author,
		&i.Guid,
		&i.Content,
		&i.ImageUrl,
		&i.Categories,
		&i.CreatedAt,
		&i.FeedID,
		&i.IsRead,
	)
	return i, err
}

const getItemBlockRuleByValue = `-- name: GetItemBlockRuleByValue :one
SELECT
  id, rule_type, rule_value, domain, created_at, updated_at
FROM
  item_block_rules
WHERE
  rule_type = ? AND 
  rule_value = ? AND 
  domain = ?
`

type GetItemBlockRuleByValueParams struct {
	RuleType  string `json:"rule_type"`
	RuleValue string `json:"rule_value"`
	Domain    string `json:"domain"`
}

func (q *Queries) GetItemBlockRuleByValue(ctx context.Context, arg GetItemBlockRuleByValueParams) (ItemBlockRule, error) {
	row := q.db.QueryRowContext(ctx, getItemBlockRuleByValue, arg.RuleType, arg.RuleValue, arg.Domain)
	var i ItemBlockRule
	err := row.Scan(
		&i.ID,
		&i.RuleType,
		&i.RuleValue,
		&i.Domain,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT
  id, name, created_at, updated_at
FROM
  tags
WHERE
  name = ?
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getURLParsingRule = `-- name: GetURLParsingRule :one
SELECT
  id, domain, rule_type, pattern, created_at, updated_at
FROM
  url_parsing_rules
WHERE
  id = ?
`

func (q *Queries) GetURLParsingRule(ctx context.Context, id string) (UrlParsingRule, error) {
	row := q.db.QueryRowContext(ctx, getURLParsingRule, id)
	var i UrlParsingRule
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RuleType,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getURLParsingRuleByDomain = `-- name: GetURLParsingRuleByDomain :one
SELECT
  id, domain, rule_type, pattern, created_at, updated_at
FROM
  url_parsing_rules
WHERE
  domain = ? AND rule_type = ?
`

type GetURLParsingRuleByDomainParams struct {
	Domain   string `json:"domain"`
	RuleType string `json:"rule_type"`
}

func (q *Queries) GetURLParsingRuleByDomain(ctx context.Context, arg GetURLParsingRuleByDomainParams) (UrlParsingRule, error) {
	row := q.db.QueryRowContext(ctx, getURLParsingRuleByDomain, arg.Domain, arg.RuleType)
	var i UrlParsingRule
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RuleType,
		&i.Pattern,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFeedTags = `-- name: ListFeedTags :many
SELECT
  feed_id,
  tag_id
FROM
  feed_tags
WHERE
  (?1 IS NULL OR feed_id = ?1)
  AND (?2 IS NULL OR tag_id = ?2)
`

type ListFeedTagsParams struct {
	FeedID interface{} `json:"feed_id"`
	TagID  interface{} `json:"tag_id"`
}

type ListFeedTagsRow struct {
	FeedID string `json:"feed_id"`
	TagID  string `json:"tag_id"`
}

func (q *Queries) ListFeedTags(ctx context.Context, arg ListFeedTagsParams) ([]ListFeedTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeedTags, arg.FeedID, arg.TagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedTagsRow
	for rows.Next() {
		var i ListFeedTagsRow
		if err := rows.Scan(&i.FeedID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.created_at, f.updated_at,
  ff.last_fetched_at,
  ff.next_fetch
FROM
  feeds f
LEFT JOIN
  feed_fetcher ff ON f.id = ff.feed_id
WHERE
  (?1 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = f.id AND ft.tag_id = ?1
  ))
ORDER BY
  f.updated_at ASC
`

type ListFeedsRow struct {
	ID            string  `json:"id"`
	Url           string  `json:"url"`
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	CreatedAt     string  `json:"created_at"`
	UpdatedAt     string  `json:"updated_at"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) ListFeeds(ctx context.Context, tagID interface{}) ([]ListFeedsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeeds, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsRow
	for rows.Next() {
		var i ListFeedsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Lang,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastFetchedAt,
			&i.NextFetch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedsByIDs = `-- name: ListFeedsByIDs :many
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.created_at, f.updated_at,
  ff.last_fetched_at,
  ff.next_fetch
FROM
  feeds f
LEFT JOIN
  feed_fetcher ff ON f.id = ff.feed_id
WHERE
  f.id IN (/*SLICE:ids*/?)
`

type ListFeedsByIDsRow struct {
	ID            string  `json:"id"`
	Url           string  `json:"url"`
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	CreatedAt     string  `json:"created_at"`
	UpdatedAt     string  `json:"updated_at"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) ListFeedsByIDs(ctx context.Context, ids []string) ([]ListFeedsByIDsRow, error) {
	query := listFeedsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsByIDsRow
	for rows.Next() {
		var i ListFeedsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Lang,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastFetchedAt,
			&i.NextFetch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedsToFetch = `-- name: ListFeedsToFetch :many
SELECT
  f.id, f.url, f.link, f.title, f.description, f.lang, f.image_url, f.copyright, f.feed_type, f.feed_version, f.created_at, f.updated_at,
  ff.last_fetched_at,
  ff.next_fetch,
  ff.etag,
  ff.last_modified
FROM
  feeds f
LEFT JOIN
  feed_fetcher ff ON f.id = ff.feed_id
WHERE
  ff.next_fetch IS NULL OR ff.next_fetch <= (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
ORDER BY
  ff.next_fetch ASC
`

type ListFeedsToFetchRow struct {
	ID            string  `json:"id"`
	Url           string  `json:"url"`
	Link          *string `json:"link"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Lang          *string `json:"lang"`
	ImageUrl      *string `json:"image_url"`
	Copyright     *string `json:"copyright"`
	FeedType      *string `json:"feed_type"`
	FeedVersion   *string `json:"feed_version"`
	CreatedAt     string  `json:"created_at"`
	UpdatedAt     string  `json:"updated_at"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
	Etag          *string `json:"etag"`
	LastModified  *string `json:"last_modified"`
}

func (q *Queries) ListFeedsToFetch(ctx context.Context) ([]ListFeedsToFetchRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeedsToFetch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedsToFetchRow
	for rows.Next() {
		var i ListFeedsToFetchRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.Lang,
			&i.ImageUrl,
			&i.Copyright,
			&i.FeedType,
			&i.FeedVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastFetchedAt,
			&i.NextFetch,
			&i.Etag,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemBlockRules = `-- name: ListItemBlockRules :many
SELECT
  id, rule_type, rule_value, domain, created_at, updated_at
FROM
  item_block_rules
ORDER BY
  rule_type ASC, rule_value ASC
`

func (q *Queries) ListItemBlockRules(ctx context.Context) ([]ItemBlockRule, error) {
	rows, err := q.db.QueryContext(ctx, listItemBlockRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemBlockRule
	for rows.Next() {
		var i ItemBlockRule
		if err := rows.Scan(
			&i.ID,
			&i.RuleType,
			&i.RuleValue,
			&i.Domain,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemBlocks = `-- name: ListItemBlocks :many
SELECT
  item_id, rule_id, created_at
FROM
  item_blocks
WHERE
  item_id = ?
`

func (q *Queries) ListItemBlocks(ctx context.Context, itemID string) ([]ItemBlock, error) {
	rows, err := q.db.QueryContext(ctx, listItemBlocks, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemBlock
	for rows.Next() {
		var i ItemBlock
		if err := rows.Scan(&i.ItemID, &i.RuleID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemFeeds = `-- name: ListItemFeeds :many
SELECT
  fi.feed_id,
  f.title AS feed_title,
  fi.published_at,
  fi.created_at
FROM
  feed_items fi
JOIN
  feeds f ON fi.feed_id = f.id
WHERE
  fi.item_id = ?
`

type ListItemFeedsRow struct {
	FeedID      string  `json:"feed_id"`
	FeedTitle   *string `json:"feed_title"`
	PublishedAt *string `json:"published_at"`
	CreatedAt   string  `json:"created_at"`
}

func (q *Queries) ListItemFeeds(ctx context.Context, itemID string) ([]ListItemFeedsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemFeeds, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemFeedsRow
	for rows.Next() {
		var i ListItemFeedsRow
		if err := rows.Scan(
			&i.FeedID,
			&i.FeedTitle,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItems = `-- name: ListItems :many
SELECT
  i.id,
  i.url,
  i.title,
  CAST(COALESCE(SUBSTR(i.description, 1, 140), '') AS TEXT) AS description,
  i.published_at,
  i.author,
  i.guid,
  i.content,
  i.image_url,
  i.categories,
  i.created_at,
  CAST(MIN(fi.feed_id) AS TEXT) AS feed_id,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read
FROM
  items i
JOIN
  feed_items fi ON i.id = fi.item_id
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
LEFT JOIN
  item_blocks ib ON i.id = ib.item_id
WHERE
  (?1 IS NULL OR fi.feed_id = ?1) AND
  (?2 IS NULL OR COALESCE(ir.is_read, 0) = ?2) AND
  (?3 IS NULL OR EXISTS (
    SELECT 1 FROM feed_tags ft WHERE ft.feed_id = fi.feed_id AND ft.tag_id = ?3
  )) AND
  (?4 IS NULL OR i.created_at >= ?4) AND
  (?5 IS NULL OR (CASE WHEN ib.item_id IS NOT NULL THEN 1 ELSE 0 END = ?5))
GROUP BY
  i.id
ORDER BY
  i.created_at ASC
LIMIT ?7 OFFSET ?6
`

type ListItemsParams struct {
	FeedID    interface{} `json:"feed_id"`
	IsRead    interface{} `json:"is_read"`
	TagID     interface{} `json:"tag_id"`
	Since     interface{} `json:"since"`
	IsBlocked interface{} `json:"is_blocked"`
	Offset    int64       `json:"offset"`
	Limit     int64       `json:"limit"`
}

type ListItemsRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description string  `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
	CreatedAt   string  `json:"created_at"`
	FeedID      string  `json:"feed_id"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems,
		arg.FeedID,
		arg.IsRead,
		arg.TagID,
		arg.Since,
		arg.IsBlocked,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.Guid,
			&i.Content,
			&i.ImageUrl,
			&i.Categories,
			&i.CreatedAt,
			&i.FeedID,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsForBlocking = `-- name: ListItemsForBlocking :many
SELECT DISTINCT
  i.id, i.url, i.title, i.description, i.published_at, i.author, i.guid, i.content, i.image_url, i.categories, i.created_at, i.updated_at,
  CAST(COALESCE(ir.is_read, 0) AS INTEGER) AS is_read
FROM
  items i
LEFT JOIN
  item_reads ir ON i.id = ir.item_id
`

type ListItemsForBlockingRow struct {
	ID          string  `json:"id"`
	Url         string  `json:"url"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	PublishedAt *string `json:"published_at"`
	Author      *string `json:"author"`
	Guid        *string `json:"guid"`
	Content     *string `json:"content"`
	ImageUrl    *string `json:"image_url"`
	Categories  *string `json:"categories"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	IsRead      int64   `json:"is_read"`
}

func (q *Queries) ListItemsForBlocking(ctx context.Context) ([]ListItemsForBlockingRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemsForBlocking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsForBlockingRow
	for rows.Next() {
		var i ListItemsForBlockingRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.PublishedAt,
			&i.Author,
			&i.Guid,
			&i.Content,
			&i.ImageUrl,
			&i.Categories,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentItemPublishedDates = `-- name: ListRecentItemPublishedDates :many
SELECT
  published_at
FROM
  feed_items
WHERE
  feed_id = ? AND published_at IS NOT NULL
ORDER BY
  published_at DESC
LIMIT ?
`

type ListRecentItemPublishedDatesParams struct {
	FeedID string `json:"feed_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListRecentItemPublishedDates(ctx context.Context, arg ListRecentItemPublishedDatesParams) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listRecentItemPublishedDates, arg.FeedID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*string
	for rows.Next() {
		var published_at *string
		if err := rows.Scan(&published_at); err != nil {
			return nil, err
		}
		items = append(items, published_at)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT
  id, name, created_at, updated_at
FROM
  tags
ORDER BY
  updated_at ASC
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByFeedIDs = `-- name: ListTagsByFeedIDs :many
SELECT
  ft.feed_id,
  t.name
FROM
  tags t
JOIN
  feed_tags ft ON t.id = ft.tag_id
WHERE
  ft.feed_id IN (/*SLICE:feed_ids*/?)
ORDER BY
  t.name ASC
`

type ListTagsByFeedIDsRow struct {
	FeedID string `json:"feed_id"`
	Name   string `json:"name"`
}

func (q *Queries) ListTagsByFeedIDs(ctx context.Context, feedIds []string) ([]ListTagsByFeedIDsRow, error) {
	query := listTagsByFeedIDs
	var queryParams []interface{}
	if len(feedIds) > 0 {
		for _, v := range feedIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:feed_ids*/?", strings.Repeat(",?", len(feedIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:feed_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTagsByFeedIDsRow
	for rows.Next() {
		var i ListTagsByFeedIDsRow
		if err := rows.Scan(&i.FeedID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByFeedId = `-- name: ListTagsByFeedId :many
SELECT
  t.id, t.name, t.created_at, t.updated_at
FROM
  tags t
JOIN
  feed_tags ft ON t.id = ft.tag_id
WHERE
  ft.feed_id = ?
ORDER BY
  t.name ASC
`

func (q *Queries) ListTagsByFeedId(ctx context.Context, feedID string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByFeedId, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listURLParsingRules = `-- name: ListURLParsingRules :many
SELECT
  id, domain, rule_type, pattern, created_at, updated_at
FROM
  url_parsing_rules
ORDER BY
  domain ASC, rule_type ASC
`

func (q *Queries) ListURLParsingRules(ctx context.Context) ([]UrlParsingRule, error) {
	rows, err := q.db.QueryContext(ctx, listURLParsingRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UrlParsingRule
	for rows.Next() {
		var i UrlParsingRule
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.RuleType,
			&i.Pattern,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFeedFetched = `-- name: MarkFeedFetched :exec
INSERT INTO feed_fetcher (
  feed_id,
  last_fetched_at,
  next_fetch
) VALUES (
  ?, ?, ?
)
ON CONFLICT(feed_id) DO UPDATE SET
  last_fetched_at = COALESCE(excluded.last_fetched_at, feed_fetcher.last_fetched_at),
  next_fetch = COALESCE(excluded.next_fetch, feed_fetcher.next_fetch),
  updated_at = (strftime('%FT%TZ', 'now'))
`

type MarkFeedFetchedParams struct {
	FeedID        string  `json:"feed_id"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) MarkFeedFetched(ctx context.Context, arg MarkFeedFetchedParams) error {
	_, err := q.db.ExecContext(ctx, markFeedFetched, arg.FeedID, arg.LastFetchedAt, arg.NextFetch)
	return err
}

const setItemRead = `-- name: SetItemRead :one
INSERT INTO item_reads (
  item_id,
  is_read,
  read_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(item_id) DO UPDATE SET
  is_read = excluded.is_read,
  read_at = excluded.read_at,
  updated_at = (strftime('%FT%TZ', 'now'))
RETURNING item_id, is_read, read_at, created_at, updated_at
`

type SetItemReadParams struct {
	ItemID string  `json:"item_id"`
	IsRead int64   `json:"is_read"`
	ReadAt *string `json:"read_at"`
}

func (q *Queries) SetItemRead(ctx context.Context, arg SetItemReadParams) (ItemRead, error) {
	row := q.db.QueryRowContext(ctx, setItemRead, arg.ItemID, arg.IsRead, arg.ReadAt)
	var i ItemRead
	err := row.Scan(
		&i.ItemID,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFeed = `-- name: UpdateFeed :one
UPDATE
  feeds
SET
  link = ?,
  title = ?,
  description = ?,
  lang = ?,
  image_url = ?,
  copyright = ?,
  feed_type = ?,
  feed_version = ?,
  updated_at = (strftime('%FT%TZ', 'now'))
WHERE
  id = ?
RETURNING id, url, link, title, description, lang, image_url, copyright, feed_type, feed_version, created_at, updated_at
`

type UpdateFeedParams struct {
	Link        *string `json:"link"`
	Title       *string `json:"title"`
	Description *string `json:"description"`
	Lang        *string `json:"lang"`
	ImageUrl    *string `json:"image_url"`
	Copyright   *string `json:"copyright"`
	FeedType    *string `json:"feed_type"`
	FeedVersion *string `json:"feed_version"`
	ID          string  `json:"id"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, updateFeed,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.Lang,
		arg.ImageUrl,
		arg.Copyright,
		arg.FeedType,
		arg.FeedVersion,
		arg.ID,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Link,
		&i.Title,
		&i.Description,
		&i.Lang,
		&i.ImageUrl,
		&i.Copyright,
		&i.FeedType,
		&i.FeedVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFeedFetcher = `-- name: UpsertFeedFetcher :one
INSERT INTO feed_fetcher (
  feed_id,
  etag,
  last_modified,
  last_fetched_at,
  next_fetch
) VALUES (
  ?, ?, ?, ?, ?
)
ON CONFLICT(feed_id) DO UPDATE SET
  etag = excluded.etag,
  last_modified = excluded.last_modified,
  last_fetched_at = COALESCE(excluded.last_fetched_at, feed_fetcher.last_fetched_at),
  next_fetch = COALESCE(excluded.next_fetch, feed_fetcher.next_fetch),
  updated_at = (strftime('%FT%TZ', 'now'))
RETURNING feed_id, etag, last_modified, last_fetched_at, next_fetch, created_at, updated_at
`

type UpsertFeedFetcherParams struct {
	FeedID        string  `json:"feed_id"`
	Etag          *string `json:"etag"`
	LastModified  *string `json:"last_modified"`
	LastFetchedAt *string `json:"last_fetched_at"`
	NextFetch     *string `json:"next_fetch"`
}

func (q *Queries) UpsertFeedFetcher(ctx context.Context, arg UpsertFeedFetcherParams) (FeedFetcher, error) {
	row := q.db.QueryRowContext(ctx, upsertFeedFetcher,
		arg.FeedID,
		arg.Etag,
		arg.LastModified,
		arg.LastFetchedAt,
		arg.NextFetch,
	)
	var i FeedFetcher
	err := row.Scan(
		&i.FeedID,
		&i.Etag,
		&i.LastModified,
		&i.LastFetchedAt,
		&i.NextFetch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
