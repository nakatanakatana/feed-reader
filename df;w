import { createClient } from "@connectrpc/connect";
import { queryCollectionOptions } from "@tanstack/query-db-collection";
import {
  createCollection,
  createTransaction,
  localStorageCollectionOptions,
} from "@tanstack/solid-db";
import type { ListFeed } from "../gen/feed/v1/feed_pb";
import { FeedService } from "../gen/feed/v1/feed_pb";
import { ItemService, type ListItem } from "../gen/item/v1/item_pb";
import type { ListTag } from "../gen/tag/v1/tag_pb";
import { TagService } from "../gen/tag/v1/tag_pb";
import {
  type DateFilterValue,
  dateToTimestamp,
  getPublishedSince,
} from "./item-utils";
import { queryClient, transport } from "./query";

export interface Tag {
  id: string;
  name: string;
  unreadCount?: bigint;
}

export interface Feed {
  id: string;
  url: string;
  link?: string;
  title: string;
  unreadCount?: bigint;
  lastFetchedAt?: string;
  tags?: Tag[];
}

export interface FeedTag {
  id: string;
  feedId: string;
  tagId: string;
}

export interface Item {
  id: string;
  title: string;
  description?: string;
  publishedAt: string;
  isRead: boolean;
  createdAt: string;
  feedId: string;
}

const feedClient = createClient(FeedService, transport);
const itemClient = createClient(ItemService, transport);
const tagClient = createClient(TagService, transport);

export const addFeed = async (url: string, tagIds?: string[]) => {
  const response = await feedClient.createFeed({ url, tagIds });
  queryClient.invalidateQueries({ queryKey: ["feeds"] });
  return response.feed;
};

export const updateItemStatus = async (params: {
  ids: string[];
  isRead?: boolean;
}) => {
  await itemClient.updateItemStatus(params);
  // queryClient.invalidateQueries({ queryKey: ["items"] });
};

export const tags = createCollection(
  queryCollectionOptions({
    id: "tags",
    queryClient,
    queryKey: ["tags"],
    queryFn: async () => {
      const response = await tagClient.listTags({});
      return response.tags.map((tag: ListTag) => ({
        id: tag.id,
        name: tag.name,
        unreadCount: tag.unreadCount,
      }));
    },
    getKey: (tag: Tag) => tag.id,
  }),
);

export const feeds = createCollection(
  queryCollectionOptions({
    id: "feeds",
    queryClient,
    queryKey: ["feeds"],
	gcTime: 30*1000,
    queryFn: async () => {
      const response = await feedClient.listFeeds({});
      return response.feeds.map((feed: ListFeed) => ({
        id: feed.id,
        url: feed.url,
        link: feed.link,
        title: feed.title,
        unreadCount: feed.unreadCount,
        lastFetchedAt: feed.lastFetchedAt,
        tags: feed.tags,
      }));
    },
    getKey: (feed: Feed) => feed.id,
    onInsert: async () => {
      // In a real app, we might want to call the API here.
      // But the spec says "Minimal UX regression: Synchronization behavior should remain reliable."
      // For now we just sync with the query.
    },
    onDelete: async ({ transaction }) => {
      for (const mutation of transaction.mutations) {
        if (mutation.type === "delete") {
          await feedClient.deleteFeed({ id: mutation.key as string });
        }
      }
    },
  }),
);

export const feedTag = createCollection(
  queryCollectionOptions({
    id: "feed-tags",
    queryClient,
    queryKey: ["feed-tags"],
    queryFn: async () => {
      // Build feedTag from feeds Collection
      const feedTags: FeedTag[] = [];
      feeds.toArray.forEach((feed: Feed) => {
        feed.tags?.forEach((tag: Tag) => {
          feedTags.push({
            id: `${feed.id}-${tag.id}`, // Unique ID
            feedId: feed.id,
            tagId: tag.id,
          });
        });
      });

	  console.log("feeds", feeds.toArray)
	  console.log("feedtags", feedTags)
      return feedTags;
    },
    getKey: (feedTag: FeedTag) => feedTag.id,
  }),
);

export const localRead = createCollection(
  localStorageCollectionOptions({
    id: "local-read-items",
    storageKey: "local-read-items",
    getKey: (item: { id: string }) => item.id,
    onInsert: async ({ transaction }) => {
      const ids = transaction.mutations.map((mutation) => mutation.modified.id);
      await updateItemStatus({
        ids: ids,
        isRead: true,
      });
    },
    onDelete: async () => {},
  }),
);

export const createItemBulkMarkAsReadTx = () =>
  createTransaction({
    mutationFn: async ({ transaction }) => {
      const ids = transaction.mutations
        // @ts-expect-error
        .filter((m) => m.collection === localRead)
        .map((m) => m.modified.id);

      console.log("ids", ids);
      localRead.utils.acceptMutations(transaction);
    },
  });

export const createItems = (showRead: boolean, since: DateFilterValue) => {
  let lastFetched: Date | null = null;
  const isRead = showRead ? {} : { isRead: false };
  const sinceTimestamp = since !== "all" ? getPublishedSince(since) : undefined;
  const items = createCollection(
    queryCollectionOptions({
      id: "items",
      queryClient,
      refetchInterval: 1 * 60 * 1000,
      queryKey: ["items", { since }],
      queryFn: async ({ queryKey }) => {
        const existingData = queryClient.getQueryData(queryKey) || [];
        const searchSince =
          lastFetched === null ? sinceTimestamp : dateToTimestamp(lastFetched);
        const response = await itemClient.listItems({
          since: searchSince,
          limit: 10000,
          offset: 0,
          ...isRead,
        });
        lastFetched = new Date();

        const respList = response.items.map((item: ListItem) => ({
          id: item.id,
          title: item.title,
          description: item.description,
          publishedAt: item.publishedAt,
          isRead: item.isRead,
          createdAt: item.createdAt,
          feedId: item.feedId,
        }));

        // @ts-expect-error
        return [...existingData, ...respList];
      },
      getKey: (item: ListItem) => item.id,
    }),
  );

  return items;
};

// We still export a "db" object if we want to follow the spec's "Initialize the TanStack DB instance"
// even if it's just a collection of collections.
export const db = {
  feeds,
  feedTag,
  localRead,
  tags,
};
